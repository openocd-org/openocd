# SPDX-License-Identifier: GPL-2.0-or-later

# OpenOCD Target Configuration for SCR Processors
#
# Copyright (c) 2022-2025, Syntacore LLC
#
# This configuration file offers several customization options to support a
# wide range of devices and usage scenarios. It can be used when each TAP in
# the system has only one DM/RISCV hart connected to it. If your system is more
# complex, you'll need your own target configuration file. Please consult the
# OpenOCD User Guide for information about writing such files.
#
# **Example 1:**
# Defines four OpenOCD targets to interact with 4-hart system
# ```
# > openocd \
#     -f $OPENOCD_ROOT/share/openocd/scripts/interface/$DEBUG_ADAPTER_CONFIG \
#     -f $OPENOCD_ROOT/share/openocd/scripts/target/syntacore_target.cfg \
#     -c "sc_target_config harts_num 4" \
#     -c init
# ```
#
# **Example 2:**
# Defines four OpenOCD targets and combines them into an SMP group
# ```
# > openocd \
#     -f $OPENOCD_ROOT/share/openocd/scripts/interface/$DEBUG_ADAPTER_CONFIG \
#     -f $OPENOCD_ROOT/share/openocd/scripts/target/syntacore_target.cfg \
#     -c "sc_target_config harts_num 4" \
#     -c "sc_target_config smp_configuration 1" \
#     -c init
# ```
#
# **Example 3:**
# Defines one OpenOCD target and sets adapter speed to 1 MHz
# ```
# > openocd
#     -f $OPENOCD_ROOT/share/openocd/scripts/interface/$DEBUG_ADAPTER_CONFIG \
#     -c "adapter speed 1000"
#     -f $OPENOCD_ROOT/share/openocd/scripts/target/syntacore_target.cfg \
#     -c init
# ```

# Deprecated parameters start
set __sc_target_defaults(adapter_speed) ""
set __sc_target_defaults(reset_config) none
set __sc_target_defaults(irlen) ""
set __sc_target_defaults(harts_num) ""
# Deprecated parameters end

set __sc_target_defaults(chipname) riscv
set __sc_target_defaults(expose_csrs) ""
set __sc_target_defaults(disable_EQ_triggers) 1
set __sc_target_defaults(disable_ebreak) 0

set __sc_target_defaults(smp_configuration) 0
set __sc_target_defaults(gdb_report_data_abort) 1
set __sc_target_defaults(gdb_report_register_access_error) 1

set __sc_target_defaults(work-area-enable) 0
set __sc_target_defaults(work-area-phys)   none
set __sc_target_defaults(work-area-size)   0
set __sc_target_defaults(work-area-backup) 1

# if we want to use only raw TAPs, we should turn this on
set __sc_target_defaults(no_ocd_targets) 0

# used when we want to specify non-trivial scan-chain
set __sc_target_defaults(jtag_topology) ""

proc proc_exists p {
	return [expr {[llength [info procs $p]] > 0}]
	# TODO: figure out if we need uplevel
	# return uplevel 1 [expr {[llength [info procs $p]] > 0}]
}

proc sc_pre_tap_hook {} {
}

proc sc_target_configuration_hook {tgt} {
}

proc sc_targets_ready_hook {tgts} {
}

proc sc_target_config {param value} {
	global __sc_target_defaults
	if {![info exists __sc_target_defaults($param)]} {
		error "unsupported configuration property $param"
	}
	global __sc_target_user
	set __sc_target_user($param) $value
	return ""
}

proc sc_target_config_log {msg} {
	echo "Syntacore Config: $msg"
}

proc sc_target_config_get {param {param_type ""}} {
	global __sc_target_user
	global __sc_target_defaults

	if {[info exists __sc_target_user($param)]} {
		set result $__sc_target_user($param)
		sc_target_config_log "getting $param for __sc_target... got <$result> (from user parameters)"
		if {$param_type eq "deprecated" } {
			sc_target_config_log "specification of $param via syntacore_target.cfg is deprecated!"
		}
		return $result
	}
	if {[info exists __sc_target_defaults($param)]} {
		set result $__sc_target_defaults($param)
		if {$param_type eq "critical" } {
			sc_target_config_log "getting $param for __sc_target... got <$result> (from defaults)"
		}
		return $result
	}
	error "unsupported configuration property $param"
}

proc sc_target_build_tap_descriptor {prefix suffix irlen} {
	return [dict create prefix $prefix suffix $suffix irlen $irlen]
}

proc sc_target_get_tap_name {descr} {
	return [join [lmap key {prefix suffix} { dict get $descr $key }] .]
}

proc sc_target_build_target_descriptor {name coreid tap} {
	set tapname [sc_target_get_tap_name $tap]
	return [dict create name $name coreid $coreid tapname $tapname]
}

proc sc_target_cpu_suffix {index} {
	return "cpu${index}"
}

proc sc_parse_jtag_topology_atom {atom_string} {
	set ITEMS_PER_ATOM_LIMIT 1024
	# items can have the following forms:
	# * <num>l<irlen> - <num> taps
	# * riscv<num>l<irlen> - <num> taps, one target each
	# * <num>riscvl<irlen> - single tap, <num> targets
	set atom_format1 {^(riscv)?([[:digit:]]+)l([[:digit:]]+)$}
	set atom_format2 {^([[:digit:]]+)riscvl([[:digit:]]+)$}
	if {[regexp $atom_format1 $atom_string m target_flag obj_count irlen] == 0} {
		if {[regexp $atom_format2 $atom_string m obj_count irlen] == 0} {
			error "incorrect jtag topology atom format *$atom_string*"
		}
		set taps_count 1
		set targets_count $obj_count
	} elseif {$target_flag eq ""} {
		set taps_count $obj_count
		set targets_count 0
	} else {
		set taps_count $obj_count
		set targets_count 1
	}

	if {$irlen > 32} {
		error "IRLEN $irlen is too large in topology atom *$atom_string*"
	}
	if {$irlen == 0} {
		error "IRLEN is zero in topology atom *$atom_string*"
	}
	if {$taps_count > $ITEMS_PER_ATOM_LIMIT} {
		error "number of taps ($taps_count) in *$atom_string* atom is too large"
	}
	if {$targets_count > $ITEMS_PER_ATOM_LIMIT} {
		error "number of targets ($targets_count) in *$atom_string* atom is too large"
	}
	return [dict create taps_count $taps_count targets_count $targets_count irlen $irlen]
}

proc sc_target_build_tap_map {chipname_arg topostring} {
	set MAX_CHAIN_LENGTH 10240

	set taps []
	set targets []

	foreach item [split $topostring :] {
		set item [string trim $item]
		set parsed_atom [sc_parse_jtag_topology_atom $item]

		set irlen [dict get $parsed_atom irlen]
		set taps_count [dict get $parsed_atom taps_count]
		set targets_count [dict get $parsed_atom targets_count]

		for { set tap_idx 0 } { $tap_idx < $taps_count } { incr tap_idx } {
			lappend taps [sc_target_build_tap_descriptor tap [llength $taps] $irlen]
			for {set tgt_idx 0 } { $tgt_idx < $targets_count } { incr tgt_idx } {
				set name_suffix [sc_target_cpu_suffix [llength $targets]]
				set target_name ${chipname_arg}.${name_suffix}
				set coreid [expr { $targets_count == 1 ? -1 : $tgt_idx }]
				set tap [lindex $taps end]
				lappend targets [sc_target_build_target_descriptor $target_name $coreid $tap]
			}
		}

		if {[llength $taps] > $MAX_CHAIN_LENGTH} {
			error "number of tap chain atoms ([llength $taps]) is above limit $MAX_CHAIN_LENGTH ($topostring)"
		}
	}

	if {[llength $taps] == 0} {
		error "no taps are derived from the input topology ($topostring)"
	}

	return [list $taps $targets]
}

proc init_targets {} {

	proc sc_target_get_cpu_working_area {cpu_index} {
		set work_area_base [sc_target_config_get work-area-phys]
		set work_area_size [sc_target_config_get work-area-size]
		return [format 0x%x [expr {$work_area_base - ($work_area_size * $cpu_index)}]]
	}

	proc sc_target_get_jtag_topology {} {
		set DEFAULT_TOPOLOGY "riscv1l5"
		set _HARTS_NUM [sc_target_config_get harts_num]
		set _IRLEN [sc_target_config_get irlen]
		set topostring [sc_target_config_get jtag_topology critical]
		if {$topostring ne "" && $_HARTS_NUM ne ""} {
			error "jtag_topology($topostring) and harts_num($_HARTS_NUM) are mutually exclusive"
		}
		if {$_HARTS_NUM eq "" && $_IRLEN ne "" } {
			error "user-specified irlen($_IRLEN) is not supported without harts_num specification"
		}
		if {$topostring eq "" && $_HARTS_NUM eq ""} {
			return $DEFAULT_TOPOLOGY
		}
		if {$topostring ne ""} {
			return ${topostring}
		}
		if {$_IRLEN eq ""} {
			set _IRLEN 5
		}
		return "riscv${_HARTS_NUM}l${_IRLEN}"
	}

	if {[sc_target_config_get adapter_speed] ne ""} {
		adapter speed [sc_target_config_get adapter_speed deprecated]
	}

	if {[sc_target_config_get reset_config] ne ""} {
		set _RESET_CONFIG [sc_target_config_get reset_config deprecated]
		set _RESET_CONFIG [regexp -all -inline {\S+} $_RESET_CONFIG]
		reset_config {*}$_RESET_CONFIG
	}

	sc_pre_tap_hook

	set _WORK_AREA_ENABLE [sc_target_config_get work-area-enable critical]
	if {$_WORK_AREA_ENABLE} {
		set _WORK_AREA_PHYS [sc_target_config_get work-area-phys critical]
		if {$_WORK_AREA_PHYS eq "none" || $_WORK_AREA_PHYS eq ""} {
			error "*work-area-enable* was set but *work-area-phys* is not specified"
		}
		set _WORK_AREA_SIZE [sc_target_config_get work-area-size critical]
		if {$_WORK_AREA_SIZE == 0 || $_WORK_AREA_SIZE eq ""} {
			error "*work-area-enable* was set but *work-area-size* is not specified"
		}
	}

	set jtag_topology_string [sc_target_get_jtag_topology]
	sc_target_config_log "derived jtag topology: $jtag_topology_string"
	set tapmap [sc_target_build_tap_map [sc_target_config_get chipname] $jtag_topology_string]

	foreach tap_item [lindex $tapmap 0] {
		jtag newtap [dict get $tap_item prefix] [dict get $tap_item suffix] -irlen [dict get $tap_item irlen]
	}

	foreach tgt_item [lindex $tapmap 1] {
		if {[sc_target_config_get no_ocd_targets] == 1} {
			continue
		}

		set _TARGETNAME [dict get $tgt_item name]
		set _TAPNAME [dict get $tgt_item tapname]
		target create $_TARGETNAME riscv -endian little -chain-position $_TAPNAME -rtos hwthread

		if {[dict get $tgt_item coreid] != -1} {
			# TODO: https://github.com/riscv-collab/riscv-openocd/issues/1147
			$_TARGETNAME configure -coreid [dict get $tgt_item coreid]
		}

		if {$_WORK_AREA_ENABLE} {
			set hart_index [expr {[llength [target names]] - 1}]
			$_TARGETNAME configure \
				-work-area-phys [sc_target_get_cpu_working_area $hart_index] \
				-work-area-size [sc_target_config_get work-area-size] \
				-work-area-backup [sc_target_config_get work-area-backup]
		}

		if {[proc_exists sc_target_ide_csr_cloak] == 1} {
			set HIDE_CSRS [sc_target_ide_csr_cloak]
			sc_target_config_log "sc_target_ide_csr_cloak detected, hide_csrs configured with $HIDE_CSRS"
			$_TARGETNAME riscv hide_csrs $HIDE_CSRS
		}

		if {[sc_target_config_get expose_csrs] ne ""} {
			$_TARGETNAME riscv expose_csrs [sc_target_config_get expose_csrs]
		}

		if {[sc_target_config_get disable_EQ_triggers] == 1} {
			$_TARGETNAME riscv set_enable_trigger_feature eq none
		}

		if {[sc_target_config_get disable_ebreak] == 1} {
			$_TARGETNAME riscv set_ebreakm off
			$_TARGETNAME riscv set_ebreaks off
			$_TARGETNAME riscv set_ebreaku off
		}

		sc_target_configuration_hook $_TARGETNAME
	}

	if {[sc_target_config_get gdb_report_register_access_error]} {
		gdb report_register_access_error enable
	} else {
		gdb report_register_access_error disable
	}

	if {[sc_target_config_get gdb_report_data_abort]} {
		gdb report_data_abort enable
	} else {
		gdb report_data_abort disable
	}

	if {[sc_target_config_get smp_configuration critial]} {
		if {[llength [target names]] > 1} {
			target smp {*}[target names]
		} else {
			sc_target_config_log "Warning: smp configuration was requested, but only 1 target defined"
		}
	}

	sc_targets_ready_hook [target names]
}

